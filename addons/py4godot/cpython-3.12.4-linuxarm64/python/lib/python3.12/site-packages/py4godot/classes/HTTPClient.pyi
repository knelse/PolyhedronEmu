from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.RefCounted as __refcounted__
import py4godot.classes.StreamPeer as __streampeer__
import py4godot.classes.HTTPClient as __httpclient__
import py4godot.classes.StreamPeerGZIP as __streampeergzip__
import py4godot.classes.TLSOptions as __tlsoptions__
import py4godot.classes.StreamPeerTCP as __streampeertcp__
import py4godot.classes.StreamPeerTLS as __streampeertls__
import py4godot.classes.StreamPeerBuffer as __streampeerbuffer__
import py4godot.classes.StreamPeerExtension as __streampeerextension__


class Method:
  METHOD_GET:int = 0
  METHOD_HEAD:int = 1
  METHOD_POST:int = 2
  METHOD_PUT:int = 3
  METHOD_DELETE:int = 4
  METHOD_OPTIONS:int = 5
  METHOD_TRACE:int = 6
  METHOD_CONNECT:int = 7
  METHOD_PATCH:int = 8
  METHOD_MAX:int = 9
class Status:
  STATUS_DISCONNECTED:int = 0
  STATUS_RESOLVING:int = 1
  STATUS_CANT_RESOLVE:int = 2
  STATUS_CONNECTING:int = 3
  STATUS_CANT_CONNECT:int = 4
  STATUS_CONNECTED:int = 5
  STATUS_REQUESTING:int = 6
  STATUS_BODY:int = 7
  STATUS_CONNECTION_ERROR:int = 8
  STATUS_TLS_HANDSHAKE_ERROR:int = 9
class ResponseCode:
  RESPONSE_CONTINUE:int = 100
  RESPONSE_SWITCHING_PROTOCOLS:int = 101
  RESPONSE_PROCESSING:int = 102
  RESPONSE_OK:int = 200
  RESPONSE_CREATED:int = 201
  RESPONSE_ACCEPTED:int = 202
  RESPONSE_NON_AUTHORITATIVE_INFORMATION:int = 203
  RESPONSE_NO_CONTENT:int = 204
  RESPONSE_RESET_CONTENT:int = 205
  RESPONSE_PARTIAL_CONTENT:int = 206
  RESPONSE_MULTI_STATUS:int = 207
  RESPONSE_ALREADY_REPORTED:int = 208
  RESPONSE_IM_USED:int = 226
  RESPONSE_MULTIPLE_CHOICES:int = 300
  RESPONSE_MOVED_PERMANENTLY:int = 301
  RESPONSE_FOUND:int = 302
  RESPONSE_SEE_OTHER:int = 303
  RESPONSE_NOT_MODIFIED:int = 304
  RESPONSE_USE_PROXY:int = 305
  RESPONSE_SWITCH_PROXY:int = 306
  RESPONSE_TEMPORARY_REDIRECT:int = 307
  RESPONSE_PERMANENT_REDIRECT:int = 308
  RESPONSE_BAD_REQUEST:int = 400
  RESPONSE_UNAUTHORIZED:int = 401
  RESPONSE_PAYMENT_REQUIRED:int = 402
  RESPONSE_FORBIDDEN:int = 403
  RESPONSE_NOT_FOUND:int = 404
  RESPONSE_METHOD_NOT_ALLOWED:int = 405
  RESPONSE_NOT_ACCEPTABLE:int = 406
  RESPONSE_PROXY_AUTHENTICATION_REQUIRED:int = 407
  RESPONSE_REQUEST_TIMEOUT:int = 408
  RESPONSE_CONFLICT:int = 409
  RESPONSE_GONE:int = 410
  RESPONSE_LENGTH_REQUIRED:int = 411
  RESPONSE_PRECONDITION_FAILED:int = 412
  RESPONSE_REQUEST_ENTITY_TOO_LARGE:int = 413
  RESPONSE_REQUEST_URI_TOO_LONG:int = 414
  RESPONSE_UNSUPPORTED_MEDIA_TYPE:int = 415
  RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE:int = 416
  RESPONSE_EXPECTATION_FAILED:int = 417
  RESPONSE_IM_A_TEAPOT:int = 418
  RESPONSE_MISDIRECTED_REQUEST:int = 421
  RESPONSE_UNPROCESSABLE_ENTITY:int = 422
  RESPONSE_LOCKED:int = 423
  RESPONSE_FAILED_DEPENDENCY:int = 424
  RESPONSE_UPGRADE_REQUIRED:int = 426
  RESPONSE_PRECONDITION_REQUIRED:int = 428
  RESPONSE_TOO_MANY_REQUESTS:int = 429
  RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE:int = 431
  RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS:int = 451
  RESPONSE_INTERNAL_SERVER_ERROR:int = 500
  RESPONSE_NOT_IMPLEMENTED:int = 501
  RESPONSE_BAD_GATEWAY:int = 502
  RESPONSE_SERVICE_UNAVAILABLE:int = 503
  RESPONSE_GATEWAY_TIMEOUT:int = 504
  RESPONSE_HTTP_VERSION_NOT_SUPPORTED:int = 505
  RESPONSE_VARIANT_ALSO_NEGOTIATES:int = 506
  RESPONSE_INSUFFICIENT_STORAGE:int = 507
  RESPONSE_LOOPERATOR_DETECTED:int = 508
  RESPONSE_NOT_EXTENDED:int = 510
  RESPONSE_NETWORK_AUTH_REQUIRED:int = 511


class HTTPClient(__refcounted__.RefCounted):

  @staticmethod
  def constructor()->HTTPClient:pass



  @staticmethod
  def cast(other:__object__.Object)->HTTPClient:pass


  @property
  def blocking_mode_enabled(self)->bool: pass
  @blocking_mode_enabled.setter
  def blocking_mode_enabled(self,  value:bool)->None: pass
  @property
  def connection(self)->__streampeer__.StreamPeer|__streampeertls__.StreamPeerTLS|__streampeergzip__.StreamPeerGZIP|__streampeertcp__.StreamPeerTCP|__streampeerbuffer__.StreamPeerBuffer|__streampeerextension__.StreamPeerExtension: pass
  @connection.setter
  def connection(self,  value:__streampeer__.StreamPeer)->None: pass
  @property
  def read_chunk_size(self)->int: pass
  @read_chunk_size.setter
  def read_chunk_size(self,  value:int)->None: pass
  def connect_to_host(self, host:str, port:int=-1, tls_options:__tlsoptions__.TLSOptions= __tlsoptions__.TLSOptions.constructor())->int: pass

  def set_connection(self, connection:__streampeer__.StreamPeer)->None: pass

  def get_connection(self)->__streampeer__.StreamPeer|__streampeertls__.StreamPeerTLS|__streampeergzip__.StreamPeerGZIP|__streampeertcp__.StreamPeerTCP|__streampeerbuffer__.StreamPeerBuffer|__streampeerextension__.StreamPeerExtension: pass

  def request_raw(self, method:int , url:str, headers:__core__.PackedStringArray, body:__core__.PackedByteArray)->int: pass

  def request(self, method:int , url:str, headers:__core__.PackedStringArray, body:str= __core__.String.new0())->int: pass

  def close(self)->None: pass

  def has_response(self)->bool: pass

  def is_response_chunked(self)->bool: pass

  def get_response_code(self)->int: pass

  def get_response_headers(self)->__core__.PackedStringArray: pass

  def get_response_headers_as_dictionary(self)->__core__.Dictionary: pass

  def get_response_body_length(self)->int: pass

  def read_response_body_chunk(self)->__core__.PackedByteArray: pass

  def set_read_chunk_size(self, bytes:int)->None: pass

  def get_read_chunk_size(self)->int: pass

  def set_blocking_mode(self, enabled:bool)->None: pass

  def is_blocking_mode_enabled(self)->bool: pass

  def get_status(self)->int: pass

  def poll(self)->int: pass

  def set_http_proxy(self, host:str, port:int)->None: pass

  def set_https_proxy(self, host:str, port:int)->None: pass

  def query_string_from_dict(self, fields:__core__.Dictionary)->str: pass


