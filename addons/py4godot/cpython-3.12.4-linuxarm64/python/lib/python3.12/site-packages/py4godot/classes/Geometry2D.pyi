from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.e as __e__
import py4godot.classes.P as __p__
import py4godot.classes.d as __d__
import py4godot.classes.t as __t__
import py4godot.classes.i as __i__
import py4godot.classes.k as __k__
import py4godot.classes.p as __p__
import py4godot.classes.y as __y__
import py4godot.classes.V as __v__
import py4godot.classes.Geometry2D as __geometry2d__
import py4godot.classes.A as __a__
import py4godot.classes.Object as __object__
import py4godot.classes.c as __c__
import py4godot.classes.r as __r__
import py4godot.classes.T as __t__
import py4godot.classes.2 as __2__
import py4godot.classes.a as __a__
import py4godot.classes.o as __o__


class PolyBooleanOperation:
  OPERATION_UNION:int = 0
  OPERATION_DIFFERENCE:int = 1
  OPERATION_INTERSECTION:int = 2
  OPERATION_XOR:int = 3
class PolyJoinType:
  JOIN_SQUARE:int = 0
  JOIN_ROUND:int = 1
  JOIN_MITER:int = 2
class PolyEndType:
  END_POLYGON:int = 0
  END_JOINED:int = 1
  END_BUTT:int = 2
  END_SQUARE:int = 3
  END_ROUND:int = 4


class Geometry2D(__object__.Object):



  @staticmethod
  def cast(other:__object__.Object)->Geometry2D:pass

  @staticmethod
  def instance()->Geometry2D:pass

  def is_point_in_circle(self, point:__core__.Vector2, circle_position:__core__.Vector2, circle_radius:float)->bool: pass

  def segment_intersects_circle(self, segment_from:__core__.Vector2, segment_to:__core__.Vector2, circle_position:__core__.Vector2, circle_radius:float)->float: pass

  def segment_intersects_segment(self, from_a:__core__.Vector2, to_a:__core__.Vector2, from_b:__core__.Vector2, to_b:__core__.Vector2)->object: pass

  def line_intersects_line(self, from_a:__core__.Vector2, dir_a:__core__.Vector2, from_b:__core__.Vector2, dir_b:__core__.Vector2)->object: pass

  def get_closest_points_between_segments(self, p1:__core__.Vector2, q1:__core__.Vector2, p2:__core__.Vector2, q2:__core__.Vector2)->__core__.PackedVector2Array: pass

  def get_closest_point_to_segment(self, point:__core__.Vector2, s1:__core__.Vector2, s2:__core__.Vector2)->__core__.Vector2: pass

  def get_closest_point_to_segment_uncapped(self, point:__core__.Vector2, s1:__core__.Vector2, s2:__core__.Vector2)->__core__.Vector2: pass

  def point_is_inside_triangle(self, point:__core__.Vector2, a:__core__.Vector2, b:__core__.Vector2, c:__core__.Vector2)->bool: pass

  def is_polygon_clockwise(self, polygon:__core__.PackedVector2Array)->bool: pass

  def is_point_in_polygon(self, point:__core__.Vector2, polygon:__core__.PackedVector2Array)->bool: pass

  def triangulate_polygon(self, polygon:__core__.PackedVector2Array)->__core__.PackedInt32Array: pass

  def triangulate_delaunay(self, points:__core__.PackedVector2Array)->__core__.PackedInt32Array: pass

  def convex_hull(self, points:__core__.PackedVector2Array)->__core__.PackedVector2Array: pass

  def decompose_polygon_in_convex(self, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def merge_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def clip_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def intersect_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def exclude_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def clip_polyline_with_polygon(self, polyline:__core__.PackedVector2Array, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def intersect_polyline_with_polygon(self, polyline:__core__.PackedVector2Array, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array: pass

  def offset_polygon(self, polygon:__core__.PackedVector2Array, delta:float, join_type:int =0)->typedarray::PackedVector2Array: pass

  def offset_polyline(self, polyline:__core__.PackedVector2Array, delta:float, join_type:int =0, end_type:int =3)->typedarray::PackedVector2Array: pass

  def make_atlas(self, sizes:__core__.PackedVector2Array)->__core__.Dictionary: pass

  def bresenham_line(self, from_:__core__.Vector2i, to:__core__.Vector2i)->typedarray::Vector2i: pass


